[["specimen.pathological_tumour_staging_system",{"left":{"name":"pathological_tumour_staging_system","description":"Specify the tumour staging system used to assess the cancer at the time the tumour specimen was resected. Pathological classification is based on the clinical stage information (acquired before treatment) and supplemented/modified by operative findings and pathological evaluation of the resected specimen.","valueType":"string","meta":{"core":true,"dependsOn":"sample_registration.tumour_normal_designation","notes":"This field is only required if the specimen is a tumour."},"restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]}},"right":{"name":"pathological_tumour_staging_system","description":"Specify the tumour staging system used to assess the cancer at the time the tumour specimen was resected. Pathological classification is based on the clinical stage information (acquired before treatment) and supplemented/modified by operative findings and pathological evaluation of the resected specimen.","valueType":"string","meta":{"core":true,"dependsOn":"sample_registration.tumour_normal_designation","notes":"This field is only required if the specimen is a tumour."},"restrictions":{"script":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["primary_diagnosis.basis_of_diagnosis",{"left":{"name":"basis_of_diagnosis","description":"Indicate the most valid basis of how the primary diagnosis was identified. If more than one diagnosis technique was used, select the term that has the highest code number (see notes). (Reference: IACR Standard for Basis of Diagnosis http://www.iacr.com.fr/images/doc/basis.pdf)","restrictions":{"codeList":["Death certificate only","Clinical","Clinical investigation","Specific tumour markers","Cytology","Histology of a metastasis","Histology of a primary tumour","Unknown"]},"valueType":"string","meta":{"notes":"0: Death certificate only: Information provided is from a death certificate.\n1: Clinical: Diagnosis made before death.\n2: Clinical investigation: All diagnostic techniques, including X-ray, endoscopy, imaging, ultrasound, exploratory surgery (such as laparotomy), and autopsy, without a tissue diagnosis.\n4: Specific tumour markers: Including biochemical and/or immunologic markers that are specific for a tumour site.\n5: Cytology: Examination of cells from a primary or secondary site, including fluids aspirated by endoscopy or needle; also includes the microscopic examination of peripheral blood and bone marrow aspirates.\n6: Histology of a metastasis: Histologic examination of tissue from a metastasis, including autopsy specimens.\n7: Histology of a primary tumour: Histologic examination of tissue from primary tumour, however obtained, including all cutting techniques and bone marrow biopsies; also includes autopsy specimens of primary tumour.\n9: Unknown: No information on how the diagnosis has been made."}},"diff":{"type":"deleted","data":{"name":"basis_of_diagnosis","description":"Indicate the most valid basis of how the primary diagnosis was identified. If more than one diagnosis technique was used, select the term that has the highest code number (see notes). (Reference: IACR Standard for Basis of Diagnosis http://www.iacr.com.fr/images/doc/basis.pdf)","restrictions":{"codeList":["Death certificate only","Clinical","Clinical investigation","Specific tumour markers","Cytology","Histology of a metastasis","Histology of a primary tumour","Unknown"]},"valueType":"string","meta":{"notes":"0: Death certificate only: Information provided is from a death certificate.\n1: Clinical: Diagnosis made before death.\n2: Clinical investigation: All diagnostic techniques, including X-ray, endoscopy, imaging, ultrasound, exploratory surgery (such as laparotomy), and autopsy, without a tissue diagnosis.\n4: Specific tumour markers: Including biochemical and/or immunologic markers that are specific for a tumour site.\n5: Cytology: Examination of cells from a primary or secondary site, including fluids aspirated by endoscopy or needle; also includes the microscopic examination of peripheral blood and bone marrow aspirates.\n6: Histology of a metastasis: Histologic examination of tissue from a metastasis, including autopsy specimens.\n7: Histology of a primary tumour: Histologic examination of tissue from primary tumour, however obtained, including all cutting techniques and bone marrow biopsies; also includes autopsy specimens of primary tumour.\n9: Unknown: No information on how the diagnosis has been made."}}}}],["primary_diagnosis.clinical_tumour_staging_system",{"left":{"name":"clinical_tumour_staging_system","valueType":"string","description":"Indicate the tumour staging system used to stage the cancer at the time of primary diagnosis (prior to treatment).","restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"required":true,"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]},"meta":{"core":true}},"right":{"name":"clinical_tumour_staging_system","valueType":"string","description":"Indicate the tumour staging system used to stage the cancer at the time of primary diagnosis (prior to treatment).","restrictions":{"script":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"required":true,"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]},"meta":{"core":true}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["follow_up.recurrence_tumour_staging_system",{"left":{"description":"Specify the tumour staging system used to stage the cancer at time of retreatment for recurrence or disease progression. This may be represented as rTNM in the medical report.","name":"recurrence_tumour_staging_system","valueType":"string","restrictions":{"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"],"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"]},"meta":{"core":true,"dependsOn":"follow_up.disease_status_at_followup","notes":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse."}},"right":{"description":"Specify the tumour staging system used to stage the cancer at time of retreatment for recurrence or disease progression. This may be represented as rTNM in the medical report.","name":"recurrence_tumour_staging_system","valueType":"string","restrictions":{"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"],"script":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"]},"meta":{"core":true,"dependsOn":"follow_up.disease_status_at_followup","notes":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse."}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["follow_up.posttherapy_tumour_staging_system",{"left":{"description":"Specify the tumour staging system used to stage the cancer after treatment for patients receiving systemic and/or radiation therapy alone or as a component of their initial treatment, or as neoadjuvant therapy before planned surgery. This may be represented as ypTNM or ycTNM in the medical report.","name":"posttherapy_tumour_staging_system","valueType":"string","restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]}},"right":{"description":"Specify the tumour staging system used to stage the cancer after treatment for patients receiving systemic and/or radiation therapy alone or as a component of their initial treatment, or as neoadjuvant therapy before planned surgery. This may be represented as ypTNM or ycTNM in the medical report.","name":"posttherapy_tumour_staging_system","valueType":"string","restrictions":{"script":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}]]