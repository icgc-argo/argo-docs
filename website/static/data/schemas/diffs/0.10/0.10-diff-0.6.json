{"schemas":{"sample_registration":{"updated":{"program_id":{"meta":{"notes":{"left":"This is the unique id that is assigned to your program.  If you have logged into the platform, this is the Program Id that you see in the Submiission area.","right":null},"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"gender":{"meta":{"displayName":{"left":"Gender","right":null}}},"submitter_specimen_id":{"meta":{"displayName":{"left":"Submitter Specimen ID","right":null}}},"specimen_tissue_source":{"meta":{"displayName":{"left":"Specimen Tissue Source","right":null}}},"tumour_normal_designation":{"meta":{"displayName":{"left":"Tumour Normal Designation","right":null}}},"specimen_type":{"meta":{"displayName":{"left":"Specimen Type","right":null}}},"submitter_sample_id":{"meta":{"displayName":{"left":"Submitter Sample ID","right":null}}},"sample_type":{"meta":{"displayName":{"left":"Sample Type","right":null}}}},"created":{},"deleted":{}},"donor":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"vital_status":{"meta":{"displayName":{"left":"Vital Status","right":null}}},"cause_of_death":{"meta":{"displayName":{"left":"Cause of Death","right":null}}},"survival_time":{"meta":{"displayName":{"left":"Survival Time","right":null}}},"prior_malignancy":{"meta":{"displayName":{"left":"Prior Malignancy","right":null}}},"cancer_type_prior_malignancy":{"meta":{"displayName":{"left":"Cancer Type Prior Malignancy","right":null}}},"laterality_of_prior_malignancy":{"meta":{"displayName":{"left":"Age at Prior Malignancy","right":null}}},"height":{"meta":{"displayName":{"left":"Height","right":null}}},"weight":{"meta":{"displayName":{"left":"Weight","right":null}}},"bmi":{"meta":{"displayName":{"left":"BMI","right":null}}},"menopause_status":{"meta":{"displayName":{"left":"Menopause Status","right":null}}},"age_at_menarche":{"meta":{"displayName":{"left":"Age at Menarche","right":null}}},"number_of_pregnancies":{"meta":{"displayName":{"left":"Number of Pregnancies","right":null}}},"number_of_children":{"meta":{"displayName":{"left":"Number of Children","right":null}}}},"created":{},"deleted":{}},"specimen":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"submitter_specimen_id":{"meta":{"displayName":{"left":"Submitter Specimen ID","right":null}}},"pathological_tumour_staging_system":{"meta":{"displayName":{"left":"Pathological Tumour Staging System","right":null}},"restrictions":{"script":{"left":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"right":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"]}}},"pathological_t_category":{"meta":{"displayName":{"left":"Pathological T Category","right":null}}},"pathological_n_category":{"meta":{"displayName":{"left":"Pathological N Category","right":null}}},"pathological_m_category":{"meta":{"displayName":{"left":"Pathological M Category","right":null}}},"pathological_stage_group":{"description":{"left":"Specify the tumour stage, based on tumour_staging_system, used to assess the cancer at the time the tumour specimen was resected.","right":"Specify the tumour stage, based on tumor_staging_system, used to assess the cancer at the time the tumour specimen was resected."},"meta":{"displayName":{"left":"Pathological Stage Group","right":null}}},"specimen_acquisition_interval":{"meta":{"displayName":{"left":"Specimen Aquisition Interval","right":null}},"restrictions":{"notes":{"left":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis.","right":null}}},"tumour_histological_type":{"meta":{"displayName":{"left":"Tumour Histological Type","right":null}}},"specimen_anatomic_location":{"meta":{"displayName":{"left":"Specimen Anatomic Location","right":null}}},"specimen_processing":{"meta":{"displayName":{"left":"Specimen Processing","right":null}}},"specimen_storage":{"meta":{"displayName":{"left":"Specimen Storage","right":null}}},"central_pathology_confirmed":{"meta":{"displayName":{"left":"Central Pathology Confirmed","right":null}}},"tumour_grading_system":{"meta":{"displayName":{"left":"Tumour Grading System","right":null}}},"tumour_grade":{"meta":{"displayName":{"left":"Tumour Grade","right":null}}},"percent_tumour_cells":{"meta":{"displayName":{"left":"Percent Tumour Cells","right":null}}},"percent_proliferating_cells":{"meta":{"displayName":{"left":"Percent Proliferating Cells","right":null}}},"percent_inflammatory_tissue":{"meta":{"displayName":{"left":"Percent Inflammatory Tissue","right":null}}},"percent_stromal_cells":{"meta":{"displayName":{"left":"Percent Stromal Cells","right":null}}},"percent_necrosis":{"meta":{"displayName":{"left":"Percent Necrosis","right":null}}}},"created":{},"deleted":{}},"primary_diagnosis":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"age_at_diagnosis":{"meta":{"displayName":{"left":"Age at Diagnosis","right":null}}},"cancer_type_code":{"description":{"left":"The code to represent the cancer type using the WHO ICD-10 code (https://icd.who.int/browse10/2019/en) classification.","right":"The code to represent the cancer type using the WHO ICD-10 code (https://icd.who.int/browse10/2016/en#/) classification."},"meta":{"displayName":{"left":"Cancer Type Code","right":null}},"restrictions":{"regex":{"left":"^[C][0-9]{2}(.[0-9]{1,3}[A-Z]{0,1})?$","right":"^C[0-9]{2}.[0-9]{0,3}[A-Z]{0,1}$"}}},"number_lymph_nodes_positive":{"meta":{"displayName":{"left":"Number Of Lymph Nodes Positive","right":null}}},"number_lymph_nodes_examined":{"meta":{"displayName":{"left":"Number Of Lymph Nodes Examined","right":null}}},"clinical_tumour_staging_system":{"meta":{"displayName":{"left":"Clinical Tumour Staging System","right":null}},"restrictions":{"script":{"left":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"right":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"]}}},"clinical_stage_group":{"meta":{"displayName":{"left":"Clinical Stage Group","right":null}}},"stage_suffix":{"meta":{"displayName":{"left":"Stage Suffix","right":null}}},"clinical_t_category":{"meta":{"displayName":{"left":"Clinical T Category","right":null}}},"clinical_n_category":{"meta":{"displayName":{"left":"Clinical N Category","right":null}}},"clinical_m_category":{"meta":{"displayName":{"left":"Clinical M Category","right":null}}},"presenting_symptoms":{"meta":{"displayName":{"left":"Presenting Symptoms","right":null}}},"performance_status":{"meta":{"displayName":{"left":"Performance Status","right":null}}}},"created":{},"deleted":{"basis_of_diagnosis":{"changeType":"deleted","name":"basis_of_diagnosis","description":"Indicate the most valid basis of how the primary diagnosis was identified. If more than one diagnosis technique was used, select the term that has the highest code number (see notes). (Reference: IACR Standard for Basis of Diagnosis http://www.iacr.com.fr/images/doc/basis.pdf)","restrictions":{"codeList":["Death certificate only","Clinical","Clinical investigation","Specific tumour markers","Cytology","Histology of a metastasis","Histology of a primary tumour","Unknown"]},"valueType":"string","meta":{"notes":"0: Death certificate only: Information provided is from a death certificate.\n1: Clinical: Diagnosis made before death.\n2: Clinical investigation: All diagnostic techniques, including X-ray, endoscopy, imaging, ultrasound, exploratory surgery (such as laparotomy), and autopsy, without a tissue diagnosis.\n4: Specific tumour markers: Including biochemical and/or immunologic markers that are specific for a tumour site.\n5: Cytology: Examination of cells from a primary or secondary site, including fluids aspirated by endoscopy or needle; also includes the microscopic examination of peripheral blood and bone marrow aspirates.\n6: Histology of a metastasis: Histologic examination of tissue from a metastasis, including autopsy specimens.\n7: Histology of a primary tumour: Histologic examination of tissue from primary tumour, however obtained, including all cutting techniques and bone marrow biopsies; also includes autopsy specimens of primary tumour.\n9: Unknown: No information on how the diagnosis has been made.","displayName":"Basis of Diagnosis"}}}},"treatment":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"submitter_treatment_id":{"meta":{"displayName":{"left":"Submitter Treatment ID","right":null}}},"treatment_type":{"meta":{"displayName":{"left":"Treatment Type","right":null}}},"age_at_consent_for_treatment":{"meta":{"displayName":{"left":"Age At Consent For Treatment","right":null}}},"is_primary_treatment":{"meta":{"displayName":{"left":"Is Primary Treatment","right":null}}},"treatment_start_interval":{"meta":{"notes":{"left":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis","right":null},"displayName":{"left":"Treatment Start Interval","right":null}}},"treatment_duration":{"meta":{"displayName":{"left":"Treatment Duration","right":null}}},"therapeutic_intent":{"meta":{"displayName":{"left":"Therapeutic Intent","right":null}}},"response_to_therapy":{"meta":{"displayName":{"left":"Response to Therapy","right":null}}}},"created":{},"deleted":{}},"chemotherapy":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"submitter_treatment_id":{"meta":{"displayName":{"left":"Submitter Treatment ID","right":null}}},"chemotherapy_drug_name":{"meta":{"displayName":{"left":"Chemotherapy Drug Name","right":null}}},"chemotherapy_dosage_units":{"meta":{"displayName":{"left":"Chemotherapy Dosage Units","right":null}},"restrictions":{"codeList":{"left":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"],"right":["mg/m²","IU/m²","µg/m²","g/m²","mg/kg"],"data":{"added":["mg/m²","IU/m²","µg/m²","g/m²"],"deleted":["mg/m2","IU/m2","µg/m2","g/m2"]}}}},"cumulative_drug_dosage":{"meta":{"displayName":{"left":"Cumulative Drug Dosage","right":null}}}},"created":{},"deleted":{}},"hormone_therapy":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"submitter_treatment_id":{"meta":{"displayName":{"left":"Submitter Treatment ID","right":null}}},"hormone_therapy_drug_name":{"meta":{"displayName":{"left":"Hormone Therapy Drug Name","right":null}}},"hormone_drug_dosage_units":{"meta":{"displayName":{"left":"Hormone Therapy Dosage Units","right":null}},"restrictions":{"codeList":{"left":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"],"right":["mg/m²","IU/m²","µg/m²","g/m²","mg/kg"],"data":{"added":["mg/m²","IU/m²","µg/m²","g/m²"],"deleted":["mg/m2","IU/m2","µg/m2","g/m2"]}}}},"cumulative_drug_dosage":{"meta":{"displayName":{"left":"Cumulative Drug Dose","right":null}}}},"created":{},"deleted":{}},"radiation":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"submitter_treatment_id":{"meta":{"displayName":{"left":"Submitter Treatment ID","right":null}}},"radiation_therapy_modality":{"meta":{"displayName":{"left":"Radiation Therapy Modality","right":null}}},"application_form":{"meta":{"displayName":{"left":"Application Form","right":null}}},"radiation_therapy_fractions":{"meta":{"displayName":{"left":"Radiation Therapy Fractions","right":null}}},"radiation_therapy_dosage":{"meta":{"displayName":{"left":"Radiation Therapy Dosage","right":null}}},"anatomical_site_irradiated":{"meta":{"displayName":{"left":"Anatomical Site Irradiated","right":null}}}},"created":{},"deleted":{}},"follow_up":{"updated":{"program_id":{"meta":{"displayName":{"left":"Program ID","right":null}}},"submitter_donor_id":{"meta":{"displayName":{"left":"Submitter Donor ID","right":null}}},"submitter_follow_up_id":{"meta":{"displayName":{"left":"Submitter Follow-Up ID","right":null}}},"interval_of_followup":{"description":{"left":"Interval from the primary diagnosis date to the follow-up date, in days.","right":"Interval from the primary diagnosis date to the follow up date, in days."},"meta":{"displayName":{"left":"Interval Of Follow-Up","right":null},"notes":{"left":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis.","right":null}}},"disease_status_at_followup":{"meta":{"displayName":{"left":"Disease Status at Follow-Up","right":null}}},"relapse_type":{"meta":{"displayName":{"left":"Relapse Type","right":null}}},"relapse_interval":{"meta":{"notes":{"left":"This field is required to be submitted if disease_status_at_followup indicates a progression or relapse value.","right":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse."},"displayName":{"left":"Relapse Interval","right":null}}},"method_of_progression_status":{"meta":{"notes":{"left":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse","right":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse."},"displayName":{"left":"Method Of Progression Status","right":null}},"restrictions":{"codeList":{"left":["Autopsy","Biomarker in liquid biopsy (e.g. tumour marker in blood or urine)","Biopsy","Blood draw","Bone marrow aspirate","Core biopsy","Cystoscopy","Cytology","Debulking","Diagnostic imaging","Dilation and curettage procedure","Enucleation","Excisional biopsy","Fine needle aspiration","Imaging","Incisional biopsy","Laparoscopy","Laparotomy","Other","Pap Smear","Pathologic review","Physical exam","Surgical resection","Thoracentesis","Ultrasound guided biopsy"],"right":["Autopsy","Biomarker in liquid biopsy (e.g. tumor marker in blood or urine)","Biopsy","Blood draw","Bone marrow aspirate","Core biopsy","Cystoscopy","Cytology","Debulking","Diagnostic imaging","Dilation and curettage procedure","Enucleation","Excisional biopsy","Fine needle aspiration","Imaging","Incisional biopsy","Laparoscopy","Laparotomy","Other","Pap Smear","Pathologic review","Physical exam","Surgical resection","Thoracentesis","Ultrasound guided biopsy"],"data":{"added":["Biomarker in liquid biopsy (e.g. tumor marker in blood or urine)"],"deleted":["Biomarker in liquid biopsy (e.g. tumour marker in blood or urine)"]}}}},"anatomic_site_progression_or_recurrences":{"meta":{"displayName":{"left":"Anatomic Site Progression or Recurrences","right":null}}},"recurrence_tumour_staging_system":{"meta":{"displayName":{"left":"Recurrance Tumour Staging System","right":null}},"restrictions":{"script":{"left":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"],"right":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"]}}},"recurrence_t_category":{"meta":{"displayName":{"left":"Recurrence T Category","right":null}}},"recurrence_n_category":{"meta":{"displayName":{"left":"Recurrence N Category","right":null}}},"recurrence_m_category":{"meta":{"displayName":{"left":"Recurrence M Category","right":null}}},"recurrence_stage_group":{"meta":{"displayName":{"left":"Recurrence Stage Group","right":null}}},"posttherapy_tumour_staging_system":{"meta":{"displayName":{"left":"Post-therapy Tumour Staging System","right":null}},"restrictions":{"script":{"left":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"right":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"]}}},"posttherapy_t_category":{"meta":{"displayName":{"left":"Post-therapy T Category","right":null}}},"posttherapy_n_category":{"meta":{"displayName":{"left":"Post-therapy N Category","right":null}}},"posttherapy_m_category":{"meta":{"displayName":{"left":"Post-therapy M Category","right":null}}},"posttherapy_stage_group":{"meta":{"displayName":{"left":"Post-therapy Stage Group","right":null}}}},"created":{},"deleted":{"weight_at_followup":{"changeType":"deleted","description":"Indicate the donor's weight, in kilograms (kg), at the time of follow-up.","name":"weight_at_followup","valueType":"integer","meta":{"displayName":"Weight at Follow-Up"}}}}}}
