[["sample_registration.program_id",{"left":{"name":"program_id","valueType":"string","description":"Unique identifier of the ARGO program.","meta":{"validationDependency":true,"primaryId":true,"examples":"PACA-AU,BR-CA","notes":"This is the unique id that is assigned to your program.  If you have logged into the platform, this is the Program Id that you see in the Submission area. For example, PACA-CA is a Program ID.","displayName":"Program ID"},"restrictions":{"required":true}},"right":{"name":"program_id","valueType":"string","description":"Unique identifier of the ARGO program.","meta":{"validationDependency":true,"primaryId":true,"examples":"PACA-AU,BR-CA","notes":"This is the unique id that is assigned to your program.  If you have logged into the platform, this is the Program Id that you see in the Submiission area.","displayName":"Program ID"},"restrictions":{"required":true}},"diff":{"meta":{"notes":{"type":"updated","data":"This is the unique id that is assigned to your program.  If you have logged into the platform, this is the Program Id that you see in the Submiission area."}}}}],["sample_registration.submitter_donor_id",{"left":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"examples":"90234,BLD_donor_89,AML-90","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"examples":"90234,BLD_donor_89,AML-90","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["sample_registration.submitter_specimen_id",{"left":{"name":"submitter_specimen_id","valueType":"string","description":"Unique identifier of the specimen, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"examples":"LAML_PO,00445,THY_099-tumour","displayName":"Submitter Specimen ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_specimen_id","valueType":"string","description":"Unique identifier of the specimen, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"examples":"LAML_PO,00445,THY_099-tumour","displayName":"Submitter Specimen ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["sample_registration.submitter_sample_id",{"left":{"name":"submitter_sample_id","valueType":"string","description":"Unique identifier of the sample, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"examples":"hnc_12,CCG_34_94583,BRCA47832-3239","displayName":"Submitter Sample ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_sample_id","valueType":"string","description":"Unique identifier of the sample, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"examples":"hnc_12,CCG_34_94583,BRCA47832-3239","displayName":"Submitter Sample ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["donor.submitter_donor_id",{"left":{"description":"Unique identifier of the donor, assigned by the data provider.","name":"submitter_donor_id","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"description":"Unique identifier of the donor, assigned by the data provider.","name":"submitter_donor_id","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["donor.prior_malignancy",{"left":{"description":"Prior malignancy affecting donor.","name":"prior_malignancy","restrictions":{"codeList":["Yes","No","Unknown"]},"valueType":"string","meta":{"displayName":"Prior Malignancy","examples":"C41.1, C16.9, C00.5, D46.9"}},"right":{"description":"Prior malignancy affecting donor.","name":"prior_malignancy","restrictions":{"codeList":["Yes","No","Unknown"]},"valueType":"string","meta":{"displayName":"Prior Malignancy"}},"diff":{"meta":{"examples":{"type":"deleted","data":"C41.1, C16.9, C00.5, D46.9"}}}}],["donor.cancer_type_prior_malignancy",{"left":{"description":"The code to represent the cancer type of a prior malignancy using the WHO ICD-10 code (https://icd.who.int/browse10/2019/en) classification.","name":"cancer_type_prior_malignancy","restrictions":{"regex":"^[C|D][0-9]{2}(.[0-9]{1,3}[A-Z]{0,1})?$"},"valueType":"string","meta":{"displayName":"Cancer Type Prior Malignancy"}},"right":{"description":"The ICD-10 diagnostic code (https://icd.who.int/browse10/2019/en) for the type of cancer in a prior malignancy.","name":"cancer_type_prior_malignancy","restrictions":{"regex":"^[C|D][0-9]{2}(.[0-9]{1,3}[A-Z]{0,1})?$"},"valueType":"string","meta":{"displayName":"Cancer Type Prior Malignancy"}},"diff":{"description":{"type":"updated","data":"The ICD-10 diagnostic code (https://icd.who.int/browse10/2019/en) for the type of cancer in a prior malignancy."}}}],["specimen.submitter_donor_id",{"left":{"name":"submitter_donor_id","description":"Unique identifier of the donor, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","description":"Unique identifier of the donor, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["specimen.submitter_specimen_id",{"left":{"name":"submitter_specimen_id","description":"Unique identifier of the specimen, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_specimen_id","displayName":"Submitter Specimen ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_specimen_id","description":"Unique identifier of the specimen, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_specimen_id","displayName":"Submitter Specimen ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["specimen.submitter_primary_diagnosis_id",{"left":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Indicate the primary diagnosis event in the clinical timeline that this specimen aquisition was related to.","meta":{"primaryId":true,"displayName":"Submitter Primary Diagnosis ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"diff":{"type":"deleted","data":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Indicate the primary diagnosis event in the clinical timeline that this specimen aquisition was related to.","meta":{"primaryId":true,"displayName":"Submitter Primary Diagnosis ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}}}}],["specimen.pathological_tumour_staging_system",{"left":{"name":"pathological_tumour_staging_system","description":"Specify the tumour staging system used to assess the cancer at the time the tumour specimen was resected. Pathological classification is based on the clinical stage information (acquired before treatment) and supplemented/modified by operative findings and pathological evaluation of the resected specimen.","valueType":"string","meta":{"core":true,"dependsOn":"sample_registration.tumour_normal_designation","notes":"This field is only required if the specimen is a tumour.","displayName":"Pathological Tumour Staging System"},"restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]}},"right":{"name":"pathological_tumour_staging_system","description":"Specify the tumour staging system used to assess the cancer at the time the tumour specimen was resected. Pathological classification is based on the clinical stage information (acquired before treatment) and supplemented/modified by operative findings and pathological evaluation of the resected specimen.","valueType":"string","meta":{"core":true,"dependsOn":"sample_registration.tumour_normal_designation","notes":"This field is only required if the specimen is a tumour.","displayName":"Pathological Tumour Staging System"},"restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["specimen.tumour_grading_system",{"left":{"name":"tumour_grading_system","description":"Specify the tumour staging system used to assess the description of a tumour based on how abnormal the tumour cells and the tumour tissue look under a microscope. Tumour grade is an indicator of how quickly a tumour is likely to grow.","valueType":"string","meta":{"core":true,"dependsOn":"sample_registration.tumour_normal_designation","notes":"This field is only required if the specimen is a tumour.","displayName":"Tumour Grading System"},"restrictions":{"codeList":["Two-tier grading system","Three-tier grading system","Four-tier grading system","Grading system for GISTs","Grading system for GNETs","ISUP grading system","WHO grading system for CNS tumours","FNCLCC grading system","Gleason grade group system","Scarff-Bloom-Richardson grading system","Nuclear grading system for DCIS"]}},"right":{"name":"tumour_grading_system","description":"Specify the tumour staging system used to assess the description of a tumour based on how abnormal the tumour cells and the tumour tissue look under a microscope. Tumour grade is an indicator of how quickly a tumour is likely to grow.","valueType":"string","meta":{"core":true,"dependsOn":"sample_registration.tumour_normal_designation","notes":"This field is only required if the specimen is a tumour.","displayName":"Tumour Grading System"},"restrictions":{"codeList":["Default","Gleason","Nottingham","Brain cancer","ISUP","Lymphoid neoplasms"]}},"diff":{"restrictions":{"codeList":{"type":"updated","data":{"added":["Default","Gleason","Nottingham","Brain cancer","ISUP","Lymphoid neoplasms"],"deleted":["Two-tier grading system","Three-tier grading system","Four-tier grading system","Grading system for GISTs","Grading system for GNETs","ISUP grading system","WHO grading system for CNS tumours","FNCLCC grading system","Gleason grade group system","Scarff-Bloom-Richardson grading system","Nuclear grading system for DCIS"]}}}}}],["specimen.tumour_grade",{"left":{"name":"tumour_grade","description":"Grade of the tumour as assigned by the reporting tumour_grading_system.","valueType":"string","meta":{"core":true,"dependsOn":"specimen.tumour_grading_system","notes":"This field depends on the selected tumour grading system, and is only required if the specimen is a tumour.","displayName":"Tumour Grade"},"restrictions":{"codeList":["Low grade","High grade","GX","G1","G2","G3","G4","Low","High","I","II","III","IV","1","2","3","4","5"],"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    if ($row.tumour_grading_system && $field) {\n      let codeList = [];\n      const tieredGradingList = ['gx','g1','g2','g3'];\n      switch ($row.tumour_grading_system && $row.tumour_grading_system.trim().toLowerCase()) {\n        case 'two-tier grading system':\n          codeList = [\n            'low grade',\n            'high grade',\n          ];\n          break;\n        case 'three-tier grading system':\n          codeList = tieredGradingList;\n          break;\n        case 'four-tier grading system':\n          codeList = [\n            'gx',\n            'g1',\n            'g2',\n            'g3',\n            'g4',\n          ];\n          break;\n        case 'grading system for gists':\n          codeList = [\n            'low',\n            'high',\n          ];\n          break;\n        case 'grading system for gnets':\n          codeList = tieredGradingList;\n          break;\n        case 'isup grading system':\n          codeList = [\n            'gx',\n            'g1',\n            'g2',\n            'g3',\n            'g4',\n          ];\n          break;\n        case 'who grading system for cns tumours':\n          codeList = [\n            'i',\n            'ii',\n            'iii',\n            'iv',\n          ];\n          break;\n        case 'fnclcc grading system':\n          codeList = tieredGradingList;\n          break;\n        case 'gleason grade group system':\n          codeList = [\n            '1',\n            '2',\n            '3',\n            '4',\n            '5',\n          ];\n          break;\n        case 'scarff-bloom-richardson grading system':\n          codeList = tieredGradingList;\n          break;\n        case 'nuclear grading system for dcis':\n          codeList = tieredGradingList;\n          break;\n        default:\n          codelist = [];\n      }\n\n      if (!codeList.includes($field.trim().toLowerCase()) && codeList.length) {\n        const msg = `'${$field}' is not a permissible value. When 'tumour_grading_system' is set to '${\n          $row.tumour_grading_system\n        }', 'tumour_grade' must be one of the following: \\n${codeList\n          .map(code => `- \"${code}\"`)\n          .join('\\n')}`;\n\n        result.valid = false;\n        result.message = msg;\n      }\n    }\n    return result;\n  })()"]}},"right":{"name":"tumour_grade","description":"Grade of the tumour as assigned by the reporting tumour_grading_system.","valueType":"string","meta":{"core":true,"dependsOn":"specimen.tumour_grading_system","notes":"This field depends on the selected tumour grading system, and is only required if the specimen is a tumour.","displayName":"Tumour Grade"},"restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    if ($row.tumour_grading_system && $field) {\n      let codeList = [];\n\n      switch ($row.tumour_grading_system && $row.tumour_grading_system.trim().toLowerCase()) {\n        case 'default':\n          codeList = [\n            'gx - cannot be assessed',\n            'g1 well differentiated/low grade',\n            'g2 moderately differentiated/intermediated grade',\n            'g3 poorly differentiated/high grade',\n            'g4 undifferentiated/high grade',\n          ];\n          break;\n        case 'gleason':\n          codeList = [\n            'gleason x: gleason score cannot be determined',\n            'gleason 2–6: the tumor tissue is well differentiated',\n            'gleason 7: the tumor tissue is moderately differentiated',\n            'gleason 8–10: the tumor tissue is poorly differentiated or undifferentiated',\n          ];\n          break;\n        case 'nottingham':\n          codeList = [\n            'g1 (low grade or well differentiated)',\n            'g2 (intermediate grade or moderately differentiated)',\n            'g3 (high grade or poorly differentiated)',\n          ];\n          break;\n        case 'brain cancer':\n          codeList = ['grade i', 'grade ii', 'grade iii', 'grade iv'];\n          break;\n        case 'isup for renal cell carcinoma':\n          codeList = [\n            'grade 1: tumor cell nucleoli invisible or small and basophilic at 400 x magnification',\n            'grade 2: tumor cell nucleoli conspicuous at 400 x magnification but inconspicuous at 100 x magnification',\n            'grade 3: tumor cell nucleoli eosinophilic and clearly visible at 100 x magnification',\n            'grade 4: tumors showing extreme nuclear pleomorphism and/or containing tumor giant cells and/or the presence of any proportion of tumor showing sarcomatoid and/or rhabdoid dedifferentiation',\n          ];\n          break;\n        case 'lymphoid neoplasms':\n          codeList = ['low grade or indolent nhl', 'high grade or aggressive nhl'];\n          break;\n        default:\n          codelist = [];\n      }\n\n      if (!codeList.includes($field.trim().toLowerCase()) && codeList.length) {\n        const msg = `'${$field}' is not a permissible value. When 'tumour_grading_system' is set to '${\n          $row.tumour_grading_system\n        }', 'tumour_grade' must be one of the following: \\n${codeList\n          .map(code => `- \"${code}\"`)\n          .join('\\n')}`;\n\n        result.valid = false;\n        result.message = msg;\n      }\n    }\n    return result;\n  })()"]}},"diff":{"restrictions":{"codeList":{"type":"deleted","data":["Low grade","High grade","GX","G1","G2","G3","G4","Low","High","I","II","III","IV","1","2","3","4","5"]},"script":{"type":"updated","data":{"added":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    if ($row.tumour_grading_system && $field) {\n      let codeList = [];\n\n      switch ($row.tumour_grading_system && $row.tumour_grading_system.trim().toLowerCase()) {\n        case 'default':\n          codeList = [\n            'gx - cannot be assessed',\n            'g1 well differentiated/low grade',\n            'g2 moderately differentiated/intermediated grade',\n            'g3 poorly differentiated/high grade',\n            'g4 undifferentiated/high grade',\n          ];\n          break;\n        case 'gleason':\n          codeList = [\n            'gleason x: gleason score cannot be determined',\n            'gleason 2–6: the tumor tissue is well differentiated',\n            'gleason 7: the tumor tissue is moderately differentiated',\n            'gleason 8–10: the tumor tissue is poorly differentiated or undifferentiated',\n          ];\n          break;\n        case 'nottingham':\n          codeList = [\n            'g1 (low grade or well differentiated)',\n            'g2 (intermediate grade or moderately differentiated)',\n            'g3 (high grade or poorly differentiated)',\n          ];\n          break;\n        case 'brain cancer':\n          codeList = ['grade i', 'grade ii', 'grade iii', 'grade iv'];\n          break;\n        case 'isup for renal cell carcinoma':\n          codeList = [\n            'grade 1: tumor cell nucleoli invisible or small and basophilic at 400 x magnification',\n            'grade 2: tumor cell nucleoli conspicuous at 400 x magnification but inconspicuous at 100 x magnification',\n            'grade 3: tumor cell nucleoli eosinophilic and clearly visible at 100 x magnification',\n            'grade 4: tumors showing extreme nuclear pleomorphism and/or containing tumor giant cells and/or the presence of any proportion of tumor showing sarcomatoid and/or rhabdoid dedifferentiation',\n          ];\n          break;\n        case 'lymphoid neoplasms':\n          codeList = ['low grade or indolent nhl', 'high grade or aggressive nhl'];\n          break;\n        default:\n          codelist = [];\n      }\n\n      if (!codeList.includes($field.trim().toLowerCase()) && codeList.length) {\n        const msg = `'${$field}' is not a permissible value. When 'tumour_grading_system' is set to '${\n          $row.tumour_grading_system\n        }', 'tumour_grade' must be one of the following: \\n${codeList\n          .map(code => `- \"${code}\"`)\n          .join('\\n')}`;\n\n        result.valid = false;\n        result.message = msg;\n      }\n    }\n    return result;\n  })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    if ($row.tumour_grading_system && $field) {\n      let codeList = [];\n      const tieredGradingList = ['gx','g1','g2','g3'];\n      switch ($row.tumour_grading_system && $row.tumour_grading_system.trim().toLowerCase()) {\n        case 'two-tier grading system':\n          codeList = [\n            'low grade',\n            'high grade',\n          ];\n          break;\n        case 'three-tier grading system':\n          codeList = tieredGradingList;\n          break;\n        case 'four-tier grading system':\n          codeList = [\n            'gx',\n            'g1',\n            'g2',\n            'g3',\n            'g4',\n          ];\n          break;\n        case 'grading system for gists':\n          codeList = [\n            'low',\n            'high',\n          ];\n          break;\n        case 'grading system for gnets':\n          codeList = tieredGradingList;\n          break;\n        case 'isup grading system':\n          codeList = [\n            'gx',\n            'g1',\n            'g2',\n            'g3',\n            'g4',\n          ];\n          break;\n        case 'who grading system for cns tumours':\n          codeList = [\n            'i',\n            'ii',\n            'iii',\n            'iv',\n          ];\n          break;\n        case 'fnclcc grading system':\n          codeList = tieredGradingList;\n          break;\n        case 'gleason grade group system':\n          codeList = [\n            '1',\n            '2',\n            '3',\n            '4',\n            '5',\n          ];\n          break;\n        case 'scarff-bloom-richardson grading system':\n          codeList = tieredGradingList;\n          break;\n        case 'nuclear grading system for dcis':\n          codeList = tieredGradingList;\n          break;\n        default:\n          codelist = [];\n      }\n\n      if (!codeList.includes($field.trim().toLowerCase()) && codeList.length) {\n        const msg = `'${$field}' is not a permissible value. When 'tumour_grading_system' is set to '${\n          $row.tumour_grading_system\n        }', 'tumour_grade' must be one of the following: \\n${codeList\n          .map(code => `- \"${code}\"`)\n          .join('\\n')}`;\n\n        result.valid = false;\n        result.message = msg;\n      }\n    }\n    return result;\n  })()"]}}}}}],["primary_diagnosis.submitter_donor_id",{"left":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["primary_diagnosis.submitter_primary_diagnosis_id",{"left":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Unique identifier of the primary diagnosis event, assigned by the data provider.","meta":{"primaryId":true,"displayName":"Submitter Primary Diagnosis ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"diff":{"type":"deleted","data":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Unique identifier of the primary diagnosis event, assigned by the data provider.","meta":{"primaryId":true,"displayName":"Submitter Primary Diagnosis ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}}}}],["primary_diagnosis.clinical_tumour_staging_system",{"left":{"name":"clinical_tumour_staging_system","valueType":"string","description":"Indicate the tumour staging system used to stage the cancer at the time of primary diagnosis (prior to treatment).","restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"required":true,"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]},"meta":{"core":true,"displayName":"Clinical Tumour Staging System"}},"right":{"name":"clinical_tumour_staging_system","valueType":"string","description":"Indicate the tumour staging system used to stage the cancer at the time of primary diagnosis (prior to treatment).","restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"required":true,"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]},"meta":{"core":true,"displayName":"Clinical Tumour Staging System"}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["primary_diagnosis.presenting_symptoms",{"left":{"name":"presenting_symptoms","description":"Indicate presenting symptoms at time of primary diagnosis.","valueType":"string","isArray":true,"restrictions":{"codeList":["Abdominal Pain","Anemia","Back Pain","Bloating","Cholangitis","Constipation","Dark Urine","Decreased Appetite","Diabetes","Diarrhea","Fatigue","Fever","Hypoglycemia","Jaundice","Nausea","None","Pale Stools","Pancreatitis","Pruritus/Itchiness","Steatorrhea","Unknown","Vomiting","Weight Loss"]},"meta":{"displayName":"Presenting Symptoms","notes":"To include multiple values, separate values with a comma ',' within your file.","examples":"Anemia,Bloating,Diabetes"}},"right":{"name":"presenting_symptoms","description":"Indicate presenting symptoms at time of primary diagnosis.","valueType":"string","restrictions":{"codeList":["Abdominal Pain","Anemia","Back Pain","Bloating","Cholangitis","Constipation","Dark Urine","Decreased Appetite","Diabetes","Diarrhea","Fatigue","Fever","Hypoglycemia","Jaundice","Nausea","None","Pale Stools","Pancreatitis","Pruritus/Itchiness","Steatorrhea","Unknown","Vomiting","Weight Loss"]},"meta":{"displayName":"Presenting Symptoms"}},"diff":{"isArray":{"type":"deleted","data":true},"meta":{"notes":{"type":"deleted","data":"To include multiple values, separate values with a comma ',' within your file."},"examples":{"type":"deleted","data":"Anemia,Bloating,Diabetes"}}}}],["treatment.submitter_donor_id",{"left":{"name":"submitter_donor_id","description":"Unique identifier of the donor, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","description":"Unique identifier of the donor, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["treatment.submitter_treatment_id",{"left":{"name":"submitter_treatment_id","description":"Unique identifier of the treatment, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_treatment_id","description":"Unique identifier of the treatment, assigned by the data provider.","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["treatment.submitter_primary_diagnosis_id",{"left":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Indicate the primary diagnosis event in the clinical timeline that this treatment was related to.","meta":{"primaryId":true,"displayName":"Submitter Primary Diagnosis ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"diff":{"type":"deleted","data":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Indicate the primary diagnosis event in the clinical timeline that this treatment was related to.","meta":{"primaryId":true,"displayName":"Submitter Primary Diagnosis ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}}}}],["treatment.treatment_type",{"left":{"name":"treatment_type","description":"Indicate the type of treatment regimen that the donor completed.","valueType":"string","restrictions":{"required":true,"codeList":["Chemotherapy","Ablation","Bone marrow transplant","Combined chemo+immunotherapy","Combined chemo+radiation therapy","Combined chemo-radiotherapy and surgery","Endoscopic therapy","Hormonal therapy","Immunotherapy","Monoclonal antibodies (for liquid tumours)","No treatment","Other targeting molecular therapy","Photodynamic therapy","Radiation therapy","Stem cell transplant","Surgical resection"]},"meta":{"validationDependency":true,"core":true,"notes":"Depending on the treatment_type selected, additional treament details may be required to be submitted.  Depending on the treatment_type selected, additional treatment details may be required to be submitted. For example, if treatment_type includes 'Chemotherapy', the supplemental Chemotherapy treatment type file is required.","displayName":"Treatment Type"}},"right":{"name":"treatment_type","description":"Indicate the type of treatment regimen that the donor completed.","valueType":"string","restrictions":{"required":true,"codeList":["Chemotherapy","Ablation","Bone marrow transplant","Combined chemo+immunotherapy","Combined chemo+radiation therapy","Combined chemo-radiotherapy and surgery","Endoscopic therapy","Hormonal therapy","Immunotherapy","Monoclonal antibodies (for liquid tumours)","No treatment","Other targeting molecular therapy","Photodynamic therapy","Radiation therapy","Stem cell transplant","Surgical resection"]},"meta":{"validationDependency":true,"core":true,"notes":"Depending on the treatment_type selected, additional treament details may be required to be submitted.","displayName":"Treatment Type"}},"diff":{"meta":{"notes":{"type":"updated","data":"Depending on the treatment_type selected, additional treament details may be required to be submitted."}}}}],["treatment.treatment_start_interval",{"left":{"name":"treatment_start_interval","description":"The interval between primary diagnosis and initiation of treatment, in days.","valueType":"integer","restrictions":{"required":true},"meta":{"core":true,"units":"days","notes":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis.","displayName":"Treatment Start Interval"}},"right":{"name":"treatment_start_interval","description":"The interval between primary diagnosis and initiation of treatment, in days.","valueType":"integer","restrictions":{"required":true},"meta":{"core":true,"units":"days","notes":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis","displayName":"Treatment Start Interval"}},"diff":{"meta":{"notes":{"type":"updated","data":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis"}}}}],["treatment.treatment_duration",{"left":{"name":"treatment_duration","description":"The duration of treatment regimen, in days.","valueType":"integer","restrictions":{"required":true},"meta":{"core":true,"units":"days","displayName":"Treatment Duration"}},"right":{"name":"treatment_duration","description":"The duration of treatment regimen, in days","valueType":"integer","restrictions":{"required":true},"meta":{"core":true,"units":"days","displayName":"Treatment Duration"}},"diff":{"description":{"type":"updated","data":"The duration of treatment regimen, in days"}}}],["chemotherapy.submitter_donor_id",{"left":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["chemotherapy.submitter_treatment_id",{"left":{"name":"submitter_treatment_id","valueType":"string","description":"Unique identifier of the treatment, as assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"treatment.submitter_treatment_id","displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_treatment_id","valueType":"string","description":"Unique identifier of the treatment, as assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"treatment.submitter_treatment_id","displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["chemotherapy.chemotherapy_dosage_units",{"left":{"name":"chemotherapy_dosage_units","description":"Indicate units used to record chemotherapy drug dosage.","valueType":"string","restrictions":{"required":true,"codeList":["mg/m2","IU/m2","ug/m2","g/m2","mg/kg"]},"meta":{"core":true,"displayName":"Chemotherapy Dosage Units"}},"right":{"name":"chemotherapy_dosage_units","description":"Indicate units used to record chemotherapy drug dosage.","valueType":"string","restrictions":{"required":true,"codeList":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"]},"meta":{"core":true,"displayName":"Chemotherapy Dosage Units"}},"diff":{"restrictions":{"codeList":{"type":"updated","data":{"added":["µg/m2"],"deleted":["ug/m2"]}}}}}],["chemotherapy.cumulative_drug_dosage",{"left":{"name":"cumulative_drug_dosage","description":"Indicate the total drug dose in the same units specified in chemotherapy_dosage_units.","valueType":"number","restrictions":{"required":true},"meta":{"core":true,"displayName":"Cumulative Drug Dosage"}},"right":{"name":"cumulative_drug_dosage","description":"Indicate the total drug dose in the same units specified in chemotherapy_dosage_units.","valueType":"integer","restrictions":{"required":true},"meta":{"core":true,"displayName":"Cumulative Drug Dosage"}},"diff":{"valueType":{"type":"updated","data":"integer"}}}],["hormone_therapy.submitter_donor_id",{"left":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["hormone_therapy.submitter_treatment_id",{"left":{"name":"submitter_treatment_id","valueType":"string","description":"Unique identifier of the treatment, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"treatment.submitter_treatment_id","displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_treatment_id","valueType":"string","description":"Unique identifier of the treatment, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"treatment.submitter_treatment_id","displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["hormone_therapy.hormone_drug_dosage_units",{"left":{"name":"hormone_drug_dosage_units","description":"Indicate the units used to record hormone drug dosage.","valueType":"string","restrictions":{"required":true,"codeList":["mg/m2","IU/m2","ug/m2","g/m2","mg/kg"]},"meta":{"core":true,"displayName":"Hormone Therapy Dosage Units"}},"right":{"name":"hormone_drug_dosage_units","description":"Indicate the units used to record hormone drug dosage.","valueType":"string","restrictions":{"required":true,"codeList":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"]},"meta":{"core":true,"displayName":"Hormone Therapy Dosage Units"}},"diff":{"restrictions":{"codeList":{"type":"updated","data":{"added":["µg/m2"],"deleted":["ug/m2"]}}}}}],["hormone_therapy.cumulative_drug_dosage",{"left":{"name":"cumulative_drug_dosage","description":"Indicate total drug dose in units specified in hormone_drug_dosage_units.","valueType":"number","restrictions":{"required":true},"meta":{"core":true,"displayName":"Cumulative Drug Dosage"}},"right":{"name":"cumulative_drug_dosage","description":"Indicate total drug dose in units specified in hormone_drug_dosage_units.","valueType":"integer","restrictions":{"required":true},"meta":{"core":true,"displayName":"Cumulative Drug Dose"}},"diff":{"valueType":{"type":"updated","data":"integer"},"meta":{"displayName":{"type":"updated","data":"Cumulative Drug Dose"}}}}],["radiation.submitter_donor_id",{"left":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_donor_id","valueType":"string","description":"Unique identifier of the donor, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["radiation.submitter_treatment_id",{"left":{"name":"submitter_treatment_id","valueType":"string","description":"Unique identifier of the treatment, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"treatment.submitter_treatment_id","displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"name":"submitter_treatment_id","valueType":"string","description":"Unique identifier of the treatment, assigned by the data provider.","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"treatment.submitter_treatment_id","displayName":"Submitter Treatment ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["radiation.application_form",{"left":{"name":"application_form","description":"Indicate type of radiation therapy administered.","valueType":"string","restrictions":{"required":true,"codeList":["External","Internal"]},"meta":{"core":true,"displayName":"Application Form","notes":"Internal application includes Brachytherapy."}},"right":{"name":"application_form","description":"Indicate type of radiation therapy administered.","valueType":"string","restrictions":{"required":true,"codeList":["External","Internal (including Brachytherapy)"]},"meta":{"core":true,"displayName":"Application Form"}},"diff":{"restrictions":{"codeList":{"type":"updated","data":{"added":["Internal (including Brachytherapy)"],"deleted":["Internal"]}}},"meta":{"notes":{"type":"deleted","data":"Internal application includes Brachytherapy."}}}}],["follow_up.submitter_donor_id",{"left":{"description":"Unique identifier of the donor, assigned by the data provider.","name":"submitter_donor_id","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"description":"Unique identifier of the donor, assigned by the data provider.","name":"submitter_donor_id","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"foreignKey":"sample_registration.submitter_donor_id","displayName":"Submitter Donor ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["follow_up.submitter_follow_up_id",{"left":{"description":"Unique identifier for a follow-up event in a donors clincal record, assigned by the data provider.","name":"submitter_follow_up_id","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"displayName":"Submitter Follow-Up ID"},"restrictions":{"required":true,"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"right":{"description":"Unique identifier for a follow-up event in a donors clincal record, assigned by the data provider.","name":"submitter_follow_up_id","valueType":"string","meta":{"validationDependency":true,"primaryId":true,"displayName":"Submitter Follow-Up ID"},"restrictions":{"required":true,"regex":"^[A-Za-z0-9\\-\\._]{1,64}$"}},"diff":{"restrictions":{"regex":{"type":"updated","data":"^[A-Za-z0-9\\-\\._]{1,64}$"}}}}],["follow_up.submitter_primary_diagnosis_id",{"left":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Indicate if the follow-up is related to a specific primary diagnosis event in the clinical timeline.","meta":{"displayName":"Submitter Primary Diagnosis ID","primaryId":true},"restrictions":{"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"diff":{"type":"deleted","data":{"name":"submitter_primary_diagnosis_id","valueType":"string","description":"Indicate if the follow-up is related to a specific primary diagnosis event in the clinical timeline.","meta":{"displayName":"Submitter Primary Diagnosis ID","primaryId":true},"restrictions":{"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}}}}],["follow_up.submitter_treatment_id",{"left":{"name":"submitter_treatment_id","valueType":"string","description":"Indicate if the follow-up is related to a specific treatment event in the clinical timeline.","meta":{"primaryId":true,"displayName":"Submitter Treatment ID"},"restrictions":{"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}},"diff":{"type":"deleted","data":{"name":"submitter_treatment_id","valueType":"string","description":"Indicate if the follow-up is related to a specific treatment event in the clinical timeline.","meta":{"primaryId":true,"displayName":"Submitter Treatment ID"},"restrictions":{"regex":"\\b(?!([Dd][Oo])|([Ss][Pp])|([Ss][Aa])|([Tt][Rr])|([pP][Dd])|([Ff][Uu]))\\b^[A-Za-z0-9\\-\\._]{1,64}"}}}}],["follow_up.method_of_progression_status",{"left":{"description":"Indicate the method(s) used to confirm the donor's progression disease status. (Codelist reference: NCI CDE ID: 6161031)","name":"method_of_progression_status","valueType":"string","restrictions":{"script":["(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"],"codeList":["Biomarker in liquid biopsy (e.g. tumour marker in blood or urine)","Biopsy","Blood draw","Bone marrow aspirate","Core biopsy","Cystoscopy","Cytology","Debulking","Diagnostic imaging","Dilation and curettage procedure","Enucleation","Excisional biopsy","Fine needle aspiration","Imaging","Incisional biopsy","Laparoscopy","Laparotomy","Other","Pap Smear","Pathologic review","Physical exam","Surgical resection","Thoracentesis","Ultrasound guided biopsy"]},"meta":{"core":true,"dependsOn":"follow_up.disease_status_at_followup","notes":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse","displayName":"Method Of Progression Status"}},"right":{"description":"Indicate the method(s) used to confirm the donor's progression disease status. (Codelist reference: NCI CDE ID: 6161031)","name":"method_of_progression_status","valueType":"string","restrictions":{"script":["(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"],"codeList":["Autopsy","Biomarker in liquid biopsy (e.g. tumour marker in blood or urine)","Biopsy","Blood draw","Bone marrow aspirate","Core biopsy","Cystoscopy","Cytology","Debulking","Diagnostic imaging","Dilation and curettage procedure","Enucleation","Excisional biopsy","Fine needle aspiration","Imaging","Incisional biopsy","Laparoscopy","Laparotomy","Other","Pap Smear","Pathologic review","Physical exam","Surgical resection","Thoracentesis","Ultrasound guided biopsy"]},"meta":{"core":true,"dependsOn":"follow_up.disease_status_at_followup","notes":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse","displayName":"Method Of Progression Status"}},"diff":{"restrictions":{"codeList":{"type":"updated","data":{"added":["Autopsy"],"deleted":[]}}}}}],["follow_up.recurrence_tumour_staging_system",{"left":{"description":"Specify the tumour staging system used to stage the cancer at time of retreatment for recurrence or disease progression. This may be represented as rTNM in the medical report.","name":"recurrence_tumour_staging_system","valueType":"string","restrictions":{"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"],"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"]},"meta":{"core":true,"dependsOn":"follow_up.disease_status_at_followup","notes":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse.","displayName":"Recurrance Tumour Staging System"}},"right":{"description":"Specify the tumour staging system used to stage the cancer at time of retreatment for recurrence or disease progression. This may be represented as rTNM in the medical report.","name":"recurrence_tumour_staging_system","valueType":"string","restrictions":{"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"],"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"]},"meta":{"core":true,"dependsOn":"follow_up.disease_status_at_followup","notes":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse.","displayName":"Recurrance Tumour Staging System"}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["follow_up.posttherapy_tumour_staging_system",{"left":{"description":"Specify the tumour staging system used to stage the cancer after treatment for patients receiving systemic and/or radiation therapy alone or as a component of their initial treatment, or as neoadjuvant therapy before planned surgery. This may be represented as ypTNM or ycTNM in the medical report.","name":"posttherapy_tumour_staging_system","valueType":"string","restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]},"meta":{"displayName":"Post-therapy Tumour Staging System"}},"right":{"description":"Specify the tumour staging system used to stage the cancer after treatment for patients receiving systemic and/or radiation therapy alone or as a component of their initial treatment, or as neoadjuvant therapy before planned surgery. This may be represented as ypTNM or ycTNM in the medical report.","name":"posttherapy_tumour_staging_system","valueType":"string","restrictions":{"script":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"codeList":["Binet","Rai","FIGO","Ann Arbor","Murphy","Lugano","AJCC 8th Edition","AJCC 7th Edition","AJCC 6th Edition","AJCC 5th Edition","AJCC 4th Edition","AJCC 3rd Edition","AJCC 2nd Edition","AJCC 1st Edition"]},"meta":{"displayName":"Post-therapy Tumour Staging System"}},"diff":{"restrictions":{"script":{"type":"updated","data":{"added":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"],"deleted":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n\n      /* search for fields with falsy values*/\n      const emptyFields = requiredFields.filter(\n        field => !convertedRow[field] || checkforEmpty(convertedRow[field]),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}}}}],["follow_up.posttherapy_stage_group",{"left":{"name":"posttherapy_stage_group","description":"The code to represent the stage group of the tumour, as assigned by the reporting posttherapy_tumour_staging_system, that indicates the overall prognostic tumour stage (ie. Stage I, Stage II, Stage III etc.) after treatment for patients receiving systemic and/or radiation therapy alone or as a component of their initial treatment, or as neoadjuvant therapy before planned surgery.","valueType":"string","meta":{"dependsOn":"follow_up.post_therapy_tumour_staging_system","notes":"This field is required only if the selected posttherapy_tumour_staging_system is any edition of the AJCC cancer staging system.","displayName":"Post-therapy Stage Group"}},"right":{"name":"posttherapy_stage_group","description":"The code to represent the stage group of the tumour, as assigned by the reporting posttherapy_tumour_staging_system, that indicates the overall prognostic tumour stage (ie. Stage I, Stage II, Stage III etc.) after treatment for patients receiving systemic and/or radiation therapy alone or as a component of their initial treatment, or as neoadjuvant therapy before planned surgery.","valueType":"string","meta":{"dependsOn":"follow_up.post_therapy_tumour_staging_system","notes":"This field value is dependent on the selected posttherapy_tumour_staging_system.","displayName":"Post-therapy Stage Group"}},"diff":{"meta":{"notes":{"type":"updated","data":"This field value is dependent on the selected posttherapy_tumour_staging_system."}}}}]]