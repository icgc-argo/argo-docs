{"schemas":{"sample_registration":{"updated":{"program_id":{"meta":{"notes":{"right":"This is the unique id that is assigned to your program.  If you have logged into the platform, this is the Program Id that you see in the Submiission area."},"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"gender":{"meta":{"displayName":{"right":"Gender"}}},"submitter_specimen_id":{"meta":{"displayName":{"right":"Submitter Specimen ID"}}},"specimen_tissue_source":{"meta":{"displayName":{"right":"Specimen Tissue Source"}}},"tumour_normal_designation":{"meta":{"displayName":{"right":"Tumour Normal Designation"}}},"specimen_type":{"meta":{"displayName":{"right":"Specimen Type"}}},"submitter_sample_id":{"meta":{"displayName":{"right":"Submitter Sample ID"}}},"sample_type":{"meta":{"displayName":{"right":"Sample Type"}}}},"created":{},"deleted":{}},"donor":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"vital_status":{"meta":{"displayName":{"right":"Vital Status"}}},"cause_of_death":{"meta":{"displayName":{"right":"Cause of Death"}}},"survival_time":{"meta":{"displayName":{"right":"Survival Time"}}},"prior_malignancy":{"meta":{}},"cancer_type_prior_malignancy":{"meta":{}},"laterality_of_prior_malignancy":{"meta":{}},"height":{"meta":{}},"weight":{"meta":{}},"bmi":{"meta":{}},"menopause_status":{"description":{"left":"Indicate the donor's menopause status at the time of primary diagnosis.","right":"Indicate the donor's menopause status at the time of primary diagnosis. (Codelist reference: NCI CDE ID: 2434914)"},"meta":{}},"age_at_menarche":{"meta":{}},"number_of_pregnancies":{"meta":{}},"number_of_children":{"meta":{}}},"created":{},"deleted":{}},"specimen":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"submitter_specimen_id":{"meta":{"displayName":{"right":"Submitter Specimen ID"}}},"pathological_tumour_staging_system":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Pathological Tumour Staging System"}},"restrictions":{"script":{"left":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"right":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]},"required":{"left":true}}},"pathological_t_category":{"meta":{"displayName":{"right":"Pathological T Category"}}},"pathological_n_category":{"meta":{"displayName":{"right":"Pathological N Category"}}},"pathological_m_category":{"meta":{"displayName":{"right":"Pathological M Category"}}},"pathological_stage_group":{"description":{"left":"Specify the tumour stage, based on tumor_staging_system, used to assess the cancer at the time the tumour specimen was resected.","right":"Specify the tumour stage, based on tumour_staging_system, used to assess the cancer at the time the tumour specimen was resected."},"meta":{"notes":{"right":"This field depends on the selected pathological staging system, and is only required if the specimen is a tumour."},"displayName":{"right":"Pathological Stage Group"}},"restrictions":{"required":{"left":true,"right":null}}},"specimen_acquisition_interval":{"meta":{"displayName":{"right":"Specimen Aquisition Interval"}},"restrictions":{}},"tumour_histological_type":{"description":{"left":"The code to represent the histology (morphology) of neoplasms that is usually obtained from a pathology report, according to the International Classification of Diseases for Oncology, 3rd Edition (WHO ICD-O-3).","right":"The code to represent the histology (morphology) of neoplasms that is usually obtained from a pathology report, according to the International Classification of Diseases for Oncology, 3rd Edition (WHO ICD-O-3). Please refer to the guidelines provided in the ICD-O-3 manual at https://apps.who.int/iris/handle/10665/42344."},"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Tumour Histological Type"}},"restrictions":{"required":{"left":true},"regex":{"left":"M-[0-9]{4}/[0-9]{2}$","right":"^[8,9]{1}[0-9]{3}/[0,1,2,3,6,9]{1}[1-9]{0,1}$"}}},"specimen_anatomic_location":{"meta":{"displayName":{"right":"Specimen Anatomic Location"}}},"specimen_processing":{"meta":{}},"specimen_storage":{"meta":{"displayName":{"right":"Specimen Storage"}}},"central_pathology_confirmed":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Central Pathology Confirmed"}},"restrictions":{"required":{"left":true}}},"tumour_grading_system":{"description":{"left":"Specify the tumour staging system used to assess the description of a tumour based on how abnormal the tumour cells and the tumour tissue look under a microscope. Tumour grade is an indicator of how quickly a tumour is likely to  grow.","right":"Specify the tumour staging system used to assess the description of a tumour based on how abnormal the tumour cells and the tumour tissue look under a microscope. Tumour grade is an indicator of how quickly a tumour is likely to grow."},"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Tumour Grading System"}},"restrictions":{"required":{"left":true}}},"tumour_grade":{"meta":{"notes":{"left":"This field depends on the selected tumour grading system.","right":"This field depends on the selected tumour grading system, and is only required if the specimen is a tumour."},"displayName":{"right":"Tumour Grade"}},"restrictions":{"script":{"left":["(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n        let codeList = [];\n        switch ($row.tumour_grading_system.trim().toLowerCase()) {\n            case 'default':\n                codeList = [\n                    'gx - cannot be assessed',\n                    'g1 well differentiated/low grade',\n                    'g2 moderately differentiated/intermediated grade',\n                    'g3 poorly differentiated/high grade',\n                    'g4 undifferentiated/high grade'\n                ];\n                break;\n            case 'gleason':\n                codeList = [\n                    'gleason x: gleason score cannot be determined',\n                    'gleason 2–6: the tumor tissue is well differentiated',\n                    'gleason 7: the tumor tissue is moderately differentiated',\n                    'gleason 8–10: the tumor tissue is poorly differentiated or undifferentiated'\n                ];\n                break;\n            case 'nottingham':\n                codeList = [\n                    'g1 (low grade or well differentiated)',\n                    'g2 (intermediate grade or moderately differentiated)',\n                    'g3 (high grade or poorly differentiated)'\n                ];\n                break;\n            case 'brain cancer':\n                codeList = [\n                    'grade i',\n                    'grade ii',\n                    'grade iii',\n                    'grade iv'\n                ];\n                break;\n            case 'isup for renal cell carcinoma':\n                codeList = [\n                    'grade 1: tumor cell nucleoli invisible or small and basophilic at 400 x magnification',\n                    'grade 2: tumor cell nucleoli conspicuous at 400 x magnification but inconspicuous at 100 x magnification',\n                    'grade 3: tumor cell nucleoli eosinophilic and clearly visible at 100 x magnification',\n                    'grade 4: tumors showing extreme nuclear pleomorphism and/or containing tumor giant cells and/or the presence of any proportion of tumor showing sarcomatoid and/or rhabdoid dedifferentiation'\n                ];\n                break;\n            case 'lymphoid neoplasms':\n                codeList = [\n                    'low grade or indolent nhl',\n                    'high grade or aggressive nhl'\n                ];\n                break;\n            default:\n                codelist = [];\n        }\n\n        if (!codeList.includes($field.trim().toLowerCase()) && codeList.length){\n            const msg = `'${$field}' is not a permissible value. When 'tumour_grading_system' is set to '${$row.tumour_grading_system}', 'tumour_grade' must be one of the following: \\n${codeList.join(\"\\n\")}`;\n\n            result.valid = false;\n            result.message = msg;\n        }\n        return result;\n    })()"],"right":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    if ($row.tumour_grading_system && $field) {\n      let codeList = [];\n\n      switch ($row.tumour_grading_system && $row.tumour_grading_system.trim().toLowerCase()) {\n        case 'default':\n          codeList = [\n            'gx - cannot be assessed',\n            'g1 well differentiated/low grade',\n            'g2 moderately differentiated/intermediated grade',\n            'g3 poorly differentiated/high grade',\n            'g4 undifferentiated/high grade',\n          ];\n          break;\n        case 'gleason':\n          codeList = [\n            'gleason x: gleason score cannot be determined',\n            'gleason 2–6: the tumor tissue is well differentiated',\n            'gleason 7: the tumor tissue is moderately differentiated',\n            'gleason 8–10: the tumor tissue is poorly differentiated or undifferentiated',\n          ];\n          break;\n        case 'nottingham':\n          codeList = [\n            'g1 (low grade or well differentiated)',\n            'g2 (intermediate grade or moderately differentiated)',\n            'g3 (high grade or poorly differentiated)',\n          ];\n          break;\n        case 'brain cancer':\n          codeList = ['grade i', 'grade ii', 'grade iii', 'grade iv'];\n          break;\n        case 'isup for renal cell carcinoma':\n          codeList = [\n            'grade 1: tumor cell nucleoli invisible or small and basophilic at 400 x magnification',\n            'grade 2: tumor cell nucleoli conspicuous at 400 x magnification but inconspicuous at 100 x magnification',\n            'grade 3: tumor cell nucleoli eosinophilic and clearly visible at 100 x magnification',\n            'grade 4: tumors showing extreme nuclear pleomorphism and/or containing tumor giant cells and/or the presence of any proportion of tumor showing sarcomatoid and/or rhabdoid dedifferentiation',\n          ];\n          break;\n        case 'lymphoid neoplasms':\n          codeList = ['low grade or indolent nhl', 'high grade or aggressive nhl'];\n          break;\n        default:\n          codelist = [];\n      }\n\n      if (!codeList.includes($field.trim().toLowerCase()) && codeList.length) {\n        const msg = `'${$field}' is not a permissible value. When 'tumour_grading_system' is set to '${\n          $row.tumour_grading_system\n        }', 'tumour_grade' must be one of the following: \\n${codeList\n          .map(code => `- \"${code}\"`)\n          .join('\\n')}`;\n\n        result.valid = false;\n        result.message = msg;\n      }\n    }\n    return result;\n  })()"]},"required":{"left":true}}},"percent_tumour_cells":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Percent Tumour Cells"}},"restrictions":{"required":{"left":true,"right":null}}},"percent_proliferating_cells":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Percent Proliferating Cells"}},"restrictions":{"required":{"left":true,"right":null}}},"percent_inflammatory_tissue":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Percent Inflammatory Tissue"}},"restrictions":{"required":{"left":true,"right":null}}},"percent_stromal_cells":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Percent Stromal Cells"}},"restrictions":{"required":{"left":true,"right":null}}},"percent_necrosis":{"meta":{"notes":{"right":"This field is only required if the specimen is a tumour."},"displayName":{"right":"Percent Necrosis"}},"restrictions":{"required":{"left":true,"right":null}}}},"created":{},"deleted":{}},"primary_diagnosis":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"age_at_diagnosis":{"meta":{"displayName":{"right":"Age at Diagnosis"}}},"cancer_type_code":{"description":{"left":"The code to represent the cancer type using the WHO ICD-10 code (https://icd.who.int/browse10/2016/en#/) classification.","right":"The code to represent the cancer type using the WHO ICD-10 code (https://icd.who.int/browse10/2019/en) classification."},"meta":{"displayName":{"right":"Cancer Type Code"}},"restrictions":{"regex":{"left":"[A-Z]{1}[0-9]{2}.[0-9]{0,3}[A-Z]{0,1}$","right":"^[C][0-9]{2}(.[0-9]{1,3}[A-Z]{0,1})?$"}}},"number_lymph_nodes_positive":{"description":{"left":"The number of regional lymph nodes reported as being positive for tumour metastases.","right":"The number of regional lymph nodes reported as being positive for tumour metastases. (Reference: NCI CDE ID: 6113694)"},"meta":{"displayName":{"right":"Number Of Lymph Nodes Positive"}}},"number_lymph_nodes_examined":{"description":{"left":"The total number of lymph nodes tested for the presence of cancer.","right":"The total number of lymph nodes tested for the presence of cancer. (Reference: NCI CDE ID: 3)"},"meta":{}},"clinical_tumour_staging_system":{"meta":{"displayName":{"right":"Clinical Tumour Staging System"}},"restrictions":{"script":{"left":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()"],"right":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}},"clinical_stage_group":{"meta":{"displayName":{"right":"Clinical Stage Group"}}},"stage_suffix":{"meta":{"displayName":{"right":"Stage Suffix"}}},"clinical_t_category":{"meta":{"displayName":{"right":"Clinical T Category"}}},"clinical_n_category":{"meta":{"displayName":{"right":"Clinical N Category"}}},"clinical_m_category":{"meta":{"displayName":{"right":"Clinical M Category"}}},"presenting_symptoms":{"meta":{}},"performance_status":{"description":{"left":"Indicate the donor's performance status grade at the time of primary diagnosis (ECOG performance score grades: https://ecog-acrin.org/resources/ecog-performance-status).","right":"Indicate the donor's performance status grade at the time of primary diagnosis. (Reference source: ECOG performance score grades from https://ecog-acrin.org/resources/ecog-performance-status)."},"meta":{"displayName":{"right":"Performance Status"}}}},"created":{"basis_of_diagnosis":{"changeType":"created","name":"basis_of_diagnosis","description":"Indicate the most valid basis of how the primary diagnosis was identified. If more than one diagnosis technique was used, select the term that has the highest code number (see notes). (Reference: IACR Standard for Basis of Diagnosis http://www.iacr.com.fr/images/doc/basis.pdf)","restrictions":{"codeList":["Death certificate only","Clinical","Clinical investigation","Specific tumour markers","Cytology","Histology of a metastasis","Histology of a primary tumour","Unknown"]},"valueType":"string","meta":{"notes":"0: Death certificate only: Information provided is from a death certificate.\n1: Clinical: Diagnosis made before death.\n2: Clinical investigation: All diagnostic techniques, including X-ray, endoscopy, imaging, ultrasound, exploratory surgery (such as laparotomy), and autopsy, without a tissue diagnosis.\n4: Specific tumour markers: Including biochemical and/or immunologic markers that are specific for a tumour site.\n5: Cytology: Examination of cells from a primary or secondary site, including fluids aspirated by endoscopy or needle; also includes the microscopic examination of peripheral blood and bone marrow aspirates.\n6: Histology of a metastasis: Histologic examination of tissue from a metastasis, including autopsy specimens.\n7: Histology of a primary tumour: Histologic examination of tissue from primary tumour, however obtained, including all cutting techniques and bone marrow biopsies; also includes autopsy specimens of primary tumour.\n9: Unknown: No information on how the diagnosis has been made.","displayName":"Basis of Diagnosis"}}},"deleted":{}},"treatment":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"submitter_treatment_id":{"meta":{"displayName":{"right":"Submitter Treatment ID"}}},"treatment_type":{"meta":{"displayName":{"right":"Treatment Type"}}},"age_at_consent_for_treatment":{"meta":{}},"is_primary_treatment":{"meta":{"displayName":{"right":"Is Primary Treatment"}}},"treatment_start_interval":{"meta":{"notes":{"right":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis"},"displayName":{"right":"Treatment Start Interval"}}},"treatment_duration":{"meta":{"displayName":{"right":"Treatment Duration"}}},"therapeutic_intent":{"meta":{"displayName":{"right":"Therapeutic Intent"}}},"response_to_therapy":{"description":{"left":"The donors's response to the applied treatment regimen.","right":"The donors's response to the applied treatment regimen. (Source: RECIST)"},"meta":{"displayName":{"right":"Response to Therapy"}}}},"created":{},"deleted":{}},"chemotherapy":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"submitter_treatment_id":{"meta":{"displayName":{"right":"Submitter Treatment ID"}}},"chemotherapy_drug_name":{"meta":{"displayName":{"right":"Chemotherapy Drug Name"}}},"chemotherapy_dosage_units":{"meta":{"displayName":{"right":"Chemotherapy Dosage Units"}},"restrictions":{"codeList":{"left":["mg/m²","IU/m²","µg/m²","g/m²","kg"],"right":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"],"data":{"added":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"],"deleted":["mg/m²","IU/m²","µg/m²","g/m²","kg"]}}}},"cumulative_drug_dosage":{"meta":{"displayName":{"right":"Cumulative Drug Dosage"}}}},"created":{},"deleted":{}},"hormone_therapy":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"submitter_treatment_id":{"meta":{"displayName":{"right":"Submitter Treatment ID"}}},"hormone_therapy_drug_name":{"meta":{"displayName":{"right":"Hormone Therapy Drug Name"}}},"hormone_drug_dosage_units":{"meta":{"displayName":{"right":"Hormone Therapy Dosage Units"}},"restrictions":{"codeList":{"left":["mg/m²","IU/m²","µg/m²","g/m²","kg "],"right":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"],"data":{"added":["mg/m2","IU/m2","µg/m2","g/m2","mg/kg"],"deleted":["mg/m²","IU/m²","µg/m²","g/m²","kg "]}}}},"cumulative_drug_dosage":{"meta":{"displayName":{"right":"Cumulative Drug Dose"}}}},"created":{},"deleted":{}},"radiation":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"submitter_treatment_id":{"meta":{"displayName":{"right":"Submitter Treatment ID"}}},"radiation_therapy_modality":{"meta":{"displayName":{"right":"Radiation Therapy Modality"}}},"application_form":{"meta":{"displayName":{"right":"Application Form"}}},"radiation_therapy_fractions":{"meta":{"displayName":{"right":"Radiation Therapy Fractions"}}},"radiation_therapy_dosage":{"meta":{"displayName":{"right":"Radiation Therapy Dosage"}}},"anatomical_site_irradiated":{"meta":{"displayName":{"right":"Anatomical Site Irradiated"}}}},"created":{},"deleted":{}},"follow_up":{"updated":{"program_id":{"meta":{"displayName":{"right":"Program ID"}}},"submitter_donor_id":{"meta":{"displayName":{"right":"Submitter Donor ID"}}},"submitter_follow_up_id":{"meta":{"displayName":{"right":"Submitter Follow-Up ID"}}},"interval_of_followup":{"description":{"left":"Interval from the primary diagnosis date to the follow up date, in days.","right":"Interval from the primary diagnosis date to the follow-up date, in days."},"meta":{"notes":{"right":"The associated Primary Diagnosis is used as the reference point for this interval. To calculate this, find the number of days since the date of primary diagnosis."},"displayName":{"right":"Interval Of Follow-Up"}}},"disease_status_at_followup":{"meta":{"displayName":{"right":"Disease Status at Follow-Up"}}},"relapse_type":{"meta":{"displayName":{"right":"Relapse Type"}}},"relapse_interval":{"meta":{"notes":{"left":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse.","right":"This field is required to be submitted if disease_status_at_followup indicates a progression or relapse value."},"displayName":{"right":"Relapse Interval"}}},"method_of_progression_status":{"description":{"left":"Indicate the method(s) used to confirm the donor's progression disease status.","right":"Indicate the method(s) used to confirm the donor's progression disease status. (Codelist reference: NCI CDE ID: 6161031)"},"meta":{"notes":{"left":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse.","right":"This field is required to be submitted if disease_status_at_followup indicates progression or relapse"},"displayName":{"right":"Method Of Progression Status"}},"restrictions":{"codeList":{"left":["Autopsy","Biomarker in liquid biopsy (e.g. tumor marker in blood or urine)","Biopsy","Blood draw","Bone marrow aspirate","Core biopsy","Cystoscopy","Cytology","Debulking","Diagnostic imaging","Dilation and curettage procedure","Enucleation","Excisional biopsy","Fine needle aspiration","Imaging","Incisional biopsy","Laparoscopy","Laparotomy","Other","Pap Smear","Pathologic review","Physical exam","Surgical resection","Thoracentesis","Ultrasound guided biopsy"],"right":["Autopsy","Biomarker in liquid biopsy (e.g. tumour marker in blood or urine)","Biopsy","Blood draw","Bone marrow aspirate","Core biopsy","Cystoscopy","Cytology","Debulking","Diagnostic imaging","Dilation and curettage procedure","Enucleation","Excisional biopsy","Fine needle aspiration","Imaging","Incisional biopsy","Laparoscopy","Laparotomy","Other","Pap Smear","Pathologic review","Physical exam","Surgical resection","Thoracentesis","Ultrasound guided biopsy"],"data":{"added":["Biomarker in liquid biopsy (e.g. tumour marker in blood or urine)"],"deleted":["Biomarker in liquid biopsy (e.g. tumor marker in blood or urine)"]}}}},"anatomic_site_progression_or_recurrences":{"description":{"left":"Indicate the anatomic site where disease progression or recurrence occurred.","right":"Indicate the anatomic site where disease progression or recurrence occurred. (Codelist reference: NCI CDE ID: 4742851)"},"meta":{"displayName":{"right":"Anatomic Site Progression or Recurrences"}}},"recurrence_tumour_staging_system":{"meta":{"displayName":{"right":"Recurrance Tumour Staging System"}},"restrictions":{"script":{"left":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"],"right":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"]}}},"recurrence_t_category":{"meta":{"displayName":{"right":"Recurrence T Category"}}},"recurrence_n_category":{"meta":{"displayName":{"right":"Recurrence N Category"}}},"recurrence_m_category":{"meta":{"displayName":{"right":"Recurrence M Category"}}},"recurrence_stage_group":{"meta":{"displayName":{"right":"Recurrence Stage Group"}}},"posttherapy_tumour_staging_system":{"meta":{},"restrictions":{"script":{"left":["(function validate() {\n\n        let result = {valid: true, message: \"Ok\"};\n        \n        /* This is not a required field, so first ensure that it exists */\n        if ($field){\n            /* Contingent on the naming system for tumour staging systems to remain consistent */\n            const stagingName = $name.trim().toLowerCase().split('_tumour_staging_system')[0];\n            /* Perform validation only if an AJCC value was selected */\n            if (/^(AJCC)\\b/i.test($field)){\n                const requiredFields = [\n                    `${stagingName}_m_category`,\n                    `${stagingName}_n_category`,\n                    `${stagingName}_t_category`\n                ];\n                const convertedRow = Object.fromEntries(Object.entries($row).map(([fieldName,fieldVal]) => [fieldName.toLowerCase(), fieldVal]));\n                /* Check for contigous spaces wrapped with quotes (empty strings) */\n                const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n                /* search for fields with falsy values, given the field exists */\n                const emptyFields = requiredFields.filter(field => Object.keys(convertedRow).includes(field) && (!convertedRow[field] || checkforEmpty(convertedRow[field])))\n                if (emptyFields.length){\n                    result = {valid: false, \"message\": `The following fields are required when ${$name} is set to an AJCC option: ${emptyFields}`};\n                }\n            }\n        }\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus.match(/(progression)$/);\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' is of type 'progression'.` }\n        }\n\n        return result;\n    })()","(function validate() {\n        let result = {valid: true, message: \"Ok\"};\n\n        /* required field, cannot be null */\n        const diseaseStatus = $row.disease_status_at_followup.trim().toLowerCase();\n\n        const isRequired = diseaseStatus === \"relapse\";\n\n        // checks for a string just consisting of whitespace\n        const checkforEmpty = (entry) => {return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'))};\n\n        if (isRequired && (!$field || checkforEmpty($field))){\n            result = {valid: false, message: `'${$name}' is a required field if 'disease_status_at_followup' set to 'relapse'.` }\n        }\n\n        return result;\n    })()"],"right":["(function validate() {\n    let result = { valid: true, message: 'Ok' };\n    const arrayFormatter = arr => `\\n${arr.map(entry => `- \"${entry}\"`).join('\\n')}`;\n    /* This is not a required field, so first ensure that it exists */\n    if ($field) {\n      /* Contingent on the naming system for tumour staging systems to remain consistent */\n      const stagingName = $name\n        .trim()\n        .toLowerCase()\n        .split('_tumour_staging_system')[0];\n      const requiredFields = [\n        `${stagingName}_m_category`,\n        `${stagingName}_n_category`,\n        `${stagingName}_t_category`,\n      ];\n      const convertedRow = Object.fromEntries(\n        Object.entries($row).map(([fieldName, fieldVal]) => [fieldName.toLowerCase(), fieldVal]),\n      );\n      /* Check for contigous spaces wrapped with quotes (empty strings) */\n      const checkforEmpty = entry => {\n        return /^\\s+$/g.test(decodeURI(entry).replace(/^\"(.*)\"$/, '$1'));\n      };\n      /* search for fields with falsy values, given the field exists */\n      const emptyFields = requiredFields.filter(\n        field =>\n          Object.keys(convertedRow).includes(field) &&\n          (!convertedRow[field] || checkforEmpty(convertedRow[field])),\n      );\n\n      /* The fields should be provided IF and ONLY IF the AJCC regex passes */\n      if (/^(AJCC)\\b/i.test($field) && emptyFields.length) {\n        result = {\n          valid: false,\n          message: `The following fields are required when ${$name} is set to an AJCC option: ${arrayFormatter(\n            emptyFields,\n          )}`,\n        };\n      } else if (!/^(AJCC)\\b/i.test($field) && emptyFields.length != requiredFields.length) {\n        const errorFields = requiredFields.filter(fieldName => !emptyFields.includes(fieldName));\n        result = {\n          valid: false,\n          message: `The following fields cannot be provided when ${$name} is not set to an AJCC option: ${arrayFormatter(\n            errorFields,\n          )}`,\n        };\n      }\n    }\n    return result;\n  })()"]}}},"posttherapy_t_category":{"meta":{"displayName":{"right":"Post-therapy T Category"}}},"posttherapy_n_category":{"meta":{"displayName":{"right":"Post-therapy N Category"}}},"posttherapy_m_category":{"meta":{"displayName":{"right":"Post-therapy M Category"}}},"posttherapy_stage_group":{"meta":{"displayName":{"right":"Post-therapy Stage Group"}}}},"created":{"weight_at_followup":{"changeType":"created","description":"Indicate the donor's weight, in kilograms (kg), at the time of follow-up.","name":"weight_at_followup","valueType":"integer","meta":{"displayName":"Weight at Follow-Up"}}},"deleted":{}}},"counts":{"updated":108,"deleted":0,"created":2}}
